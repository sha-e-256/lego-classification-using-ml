import cv2 as cv
import numpy as np

# The purpose of the smart_crop module is to provide functions that can be used to
# pre-process both training and testing

WHITE = [255, 255, 255]  # OpenCV uses GBR
BLACK = [0, 0, 0]
true_contours = []  # An array of contours that are enclosing a piece (and not just glare)

# Determine dynamic threshold using Otsu' thresholding method
# and the contours generated by that threshold
def get_threshold_and_contours(img):
    img_grey = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
    img_grey_blur = cv.GaussianBlur(src=img_grey,
                                    ksize=(13, 13), sigmaX=0)  # Kernel size has to be an odd number
    threshold, img_mask = cv.threshold(src=img_grey_blur, thresh=0, maxval=255,
                                       type=(cv.THRESH_BINARY_INV + cv.THRESH_OTSU))
    contours = cv.findContours(image=img_mask, mode=cv.RETR_EXTERNAL,
                               method=cv.CHAIN_APPROX_SIMPLE)[0]
    # First element in tuple is an array of arrays i.e. an array of contours
    # where each contour is an array of points

    return threshold, contours  # An image can contain one or more contours


# Return width and height of a bounding box
def get_bounding_box_size(b_box_rect):
    b_box_width = int(b_box_rect[1][0])  # Rows (width)
    b_box_height = int(b_box_rect[1][1])  # Cols (height)
    return b_box_width, b_box_height


# Return the coordinates of the center of the bounding box
def get_bounding_box_center(b_box_rect):
    b_box_c_x = int(b_box_rect[0][0])  # Coordinates of the center of
    b_box_c_y = int(b_box_rect[0][1])  # the bounding box
    return b_box_c_x, b_box_c_y


# Sorts the contours based off of the size of the minimum bounding box enclosed by the contour
# And returns an array of the index of the contours in order of descending bounding box size
def get_contours_sorted_by_descending_size(contours):
    b_boxes = []
    for contour in contours:
        b_box_rect = cv.minAreaRect(contour)
        (b_box_width, b_box_height) = get_bounding_box_size(b_box_rect)
        b_boxes.append((b_box_width, b_box_height))
    sorted_b_boxes = sorted(list(enumerate(b_boxes)), key=lambda x: x[1], reverse=True)
    # The lambda function allows for the list
    # to be sorted by the size of the bounding box
    # while maintaining the index
    # of the contour in the initial unsorted list

    contours_descending_size = []
    for i in range(len(sorted_b_boxes)):
        contours_descending_size.append(sorted_b_boxes[i][0])
    return contours_descending_size


# Determine the maximum border needed to enclose all pieces
# such that each image
# has a square aspect ratio, the piece is centered in the image,
# and the pieces are all scaled relative to each other
def get_max_border(max_border, min_x, min_y, max_x, max_y, c_x, c_y):
    if (c_y - min_y) > max_border: max_border = c_y - min_y
    if (max_y - c_y) > max_border: max_border = max_y - c_y
    if (c_x - min_x) > max_border: max_border = c_x - min_x
    if (max_x - c_x) > max_border: max_border = max_x - c_x
    return max_border


# Rotate the unsegmented image with respect to its center
# and increase the width and height of the image so that
# the corners of the image do not get cut off after rotation
def rotate_and_crop_img(img, contour):
    img_height = int(img.shape[0])   # Rows
    img_width = int(img.shape[1])  # Cols
    img_center_x = img_width // 2
    img_center_y = img_height //2
    b_box_rect = cv.minAreaRect(contour)
    b_box_angle = b_box_rect[2]

    # Determine rotation matrix needed to rotate
    # unsegmented image about its center
    rotation_matrix = cv.getRotationMatrix2D(center=(img_center_x, img_center_y),
                                             angle=b_box_angle, scale=1)
    cos_rotation_matrix = np.abs(rotation_matrix[0][0])  # X component of the rotation matrix
    sin_rotation_matrix = np.abs(rotation_matrix[0][1])  # Y component of the rotation matrix
    # New width/heights of unsegmented image after rotation
    rotated_img_width = int((img_height * cos_rotation_matrix) +
                            (img_width * sin_rotation_matrix))
    rotated_img_height = int((img_height * sin_rotation_matrix) +
                             (img_width * cos_rotation_matrix))
    # Update components in rotation matrix to include translation
    rotation_matrix[0][2] += (rotated_img_width // 2) - img_center_x
    rotation_matrix[1][2] += (rotated_img_height // 2) - img_center_y

    # Rotate/translate the image using the rotation matrix
    rotated_img = cv.warpAffine(src=img, M=rotation_matrix,
                                dsize=(rotated_img_width, rotated_img_height),
                                borderMode=cv.BORDER_CONSTANT, borderValue=WHITE)
    # DEBUG
    test_img = cv.resize(src=rotated_img, dsize=(2048//4, 2048//4 ), interpolation=cv.INTER_LINEAR)
    cv.imshow('r', test_img)
    cv.waitKey()
    cv.destroyAllWindows()

    b_box = cv.boxPoints(b_box_rect)
    # Rotate/translate bounding box using the rotation matrix
    rotated_b_box = cv.transform(np.array([b_box]), rotation_matrix)
    points = np.int0(rotated_b_box)[0]  # Array of points of the four corners of the bounding box
    points[points < 0] = 0  # Set negative points to be equal to zero
    min_x = points[1][1]
    max_x = points[0][1]
    min_y = points[1][0]
    max_y = points[2][0]
    cropped_img = rotated_img[min_x:max_x, min_y:max_y]
    cv.imshow('c', cropped_img)
    cv.waitKey()
    cv.destroyAllWindows()
    return cropped_img

def clear_background(img, total_threshold):
    img_grey = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
    img_threshold, _ = get_threshold_and_contours(img)
    img_background = cv.inRange(src=img_grey,
                                          lowerb=total_threshold,
                                          upperb=255)
    img[img_background > img_threshold] = WHITE  # Change
    return img

# Segment an image into 1 more sub-image, where each
# image contains a Lego piece
def smart_crop(img, dst_dir, isTest):
    threshold, contours = get_threshold_and_contours(img)
    contours_descending_size = get_contours_sorted_by_descending_size(contours)
    for i, contour_index in enumerate(contours_descending_size):
        # The contour index states the order that the bounding boxes are sorted
        # So if contours_descending_size = [2, 5] then contours[2] is the contour
        # with the maximum bounding box size
        b_box_rect = cv.minAreaRect(contours[contour_index])
        (b_box_width, b_box_height) = get_bounding_box_size(b_box_rect)
        try:
            # Examine the next biggest contour and check if the current contour
            # is at least 10x bigger than the next contour; if it is, then
            # the next contour is enclosing glare, not an actual piece
            next_b_box_rect = cv.minAreaRect(contours[contours_descending_size[i + 1]])
            (next_b_box_width, next_b_box_height) = get_bounding_box_size(next_b_box_rect)
            true_contours.append(contours[contour_index])  # Add the current contour
            if b_box_width > 10 * next_b_box_width or b_box_height > 10 * next_b_box_height:
                break  # Ignore the rest of the contours
        except IndexError as error:
            true_contours.append(contours[contour_index])
            # If there are no more contours to check against,
            # add the current piece

    for i, contour in enumerate(true_contours):
        b_box_rect = cv.minAreaRect(contour)
        (b_box_width, b_box_height) = get_bounding_box_size(b_box_rect)
        cropped_img = rotate_and_crop_img(img, contour)  # Rotate the image with

        # Expand border of image so that segmented image is a square
        # (it has a 1:1 aspect ratio)
        max_length = b_box_width if \
            b_box_width >= b_box_height else b_box_height
        offset = 2
        if max_length == b_box_width:
            # Only add from the top
            top_border_width = max_length // 2 - b_box_height // 2 + offset
            bottom_border_width = max_length // 2 - b_box_height // 2 + offset
            left_border_width = offset  # Only add offset
            right_border_width = offset
        if max_length == b_box_height:
            # Only add from the sides
            top_border_width = offset
            bottom_border_width = offset
            left_border_width = max_length // 2 - b_box_width // 2 + offset
            right_border_width = max_length // 2 - b_box_width // 2 + offset
        segmented_img = cv.copyMakeBorder(src=cropped_img,
                                          top=top_border_width,
                                          bottom=bottom_border_width,
                                          right=right_border_width,
                                          left=left_border_width,
                                          borderType=cv.BORDER_CONSTANT,
                                          value=WHITE)

        # Determine threshold for each segmented image
        # The threshold is calculated again because the threshold changes depending on the
        # differences of the colour in the image; the first time it thresholds, it considers the
        # colour of all the pieces & the background; the second time it thresholds,
        # it considers only the colour of the piece in the cropped image & the background

        # Remove background i.e. replace it with white
        # **This part doesn't work when put inside of a function
        segmented_img = clear_background(segmented_img, threshold)
        # colour of all background pixels to white

        # Scale down images to 256x256
        down_points = (256, 256)
        img_downsized = cv.resize(src=segmented_img,
                                  dsize=down_points,
                                  interpolation=cv.INTER_LINEAR)
        if isTest:
            # Name using number
            img_dst_dir = rf'{dst_dir}\{str(i)}.png'
        else:
            # Name file depending on source filename
            img_dst_dir = rf'{dst_dir}.png'
        cv.imwrite(img_dst_dir, img_downsized)
